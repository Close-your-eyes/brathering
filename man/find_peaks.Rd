% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/find_peaks.R
\name{find_peaks}
\alias{find_peaks}
\title{Find extrema or peaks in a time series by numerical procedure}
\usage{
find_peaks(
  x,
  min_gap = NULL,
  threshold = max(x)/10,
  type = c("max", "min"),
  min_mono_width = NULL,
  windowsizes = NULL,
  stepsize = NULL,
  strictly_mono = TRUE,
  type2 = "global_fallback",
  smooth = FALSE,
  verbose = TRUE
)
}
\arguments{
\item{x}{numeric vector}

\item{min_gap}{minimum number of indices of x to call two separate
extrema, min_gap>windowsize makes no sense. If NULL, defaults to
max(ceiling(length(x)/40), ceiling(min(wid)/5)) where wid is the width of
peaks as quantified by FWHM.}

\item{threshold}{min or max x value for calling an extreme, depending on type}

\item{type}{find maxima or minima}

\item{min_mono_width}{minimum number of (strictly) monotonous indices
left and right of window, either a vector of length 2 for different
left and right or one value for both; If NULL, defaults to 3 if data
appears smoothed or 1 if it does not.}

\item{windowsizes}{windowsize(s) used for iteration over x. when there is a
plateau of n extreme values, a windowsize of min n is required to detect them
as extrema; for very sharp peaks with steep slopes, an appropriate
windowsize is smaller as for wider peaks. If NULL, it is determined by
peak widths which in turned are qunatified by full width at half maximum
(FWHM).}

\item{stepsize}{step width to shift windows at; intended to speed the thing
up for very long x. If NULL, defaults to ceiling(windowsizes/10)}

\item{strictly_mono}{should slopes left and right of window of width
min_mono_width be strictly monotonous? forced to TRUE for now.}

\item{type2}{any one or multiple of "global_fallback", "local", "global";
global_fallback means that if no local extrema were found a global extreme
is returned in any case}

\item{smooth}{have x smoothed with stats::loess or stats::smooth.spline if
the initial fails}

\item{verbose}{write messages?}
}
\value{
data frame with extrema
}
\description{
A number of parameters are needed to finetune extrema/peak detection to the
desired needs. See examples. To make this completely unsupervised and
automatically meet your interpretation of what is a valid local maximum
is not possible. Selecting a proper windowsize is crucial. The function
works with indices of x (no continuous xy-pairs). With respect to min_gap this
assumes that x values are roughly equally spaced (in case x came from
xy-paired values).
}
\details{
See gcplyr::find_local_extrema or pracma::findpeaks. Also,
brathering:::estimate_peak_position may be a quicker alternative for simple
parabolic peaks.
}
\examples{
library(brathering)
x <- c(1,2,3,4,5,4,3,2,1,1,1,1,2,3,4,5,5,5,4,3,2,1,1,1,1,1,2,3,4,5,4,5,4,3,2,
       1,1,1,2,3,4,3,2,1,1,1,2,3,4,5,6,6,3,2,1,1,1,5,4,1)
# not every peak detected due to windowsize
res <- find_peaks(x = x, min_gap = 0, threshold = -Inf,
                    min_mono_width = 1,windowsizes = c(1))
plot2(res, color = "extrm", legend = NULL)
# now all peaks but also neighbouring maxima
res <- find_peaks(x = x, min_gap = 0, threshold = -Inf,
                    min_mono_width = 1,windowsizes = c(1,3))
plot2(res, color = "extrm", legend = NULL)
# use min_gap to filter consecutive extrema
res <- find_peaks(x = x, min_gap = 1, threshold = -Inf,
                    min_mono_width = 1,windowsizes = c(1,3))
plot2(res, color = "extrm", legend = NULL)
res <- find_peaks(x = x, min_gap = 2, threshold = -Inf,
                    min_mono_width = 1,windowsizes = c(1,3))
plot2(res, color = "extrm", legend = NULL)
# set a min x value: threshold
res <- find_peaks(x = x, min_gap = 1, threshold = 5,
                    min_mono_width = 1,windowsizes = c(1,3))
plot2(res, color = "extrm", legend = NULL)
# minimum steps of monotony to call an extreme
res <- find_peaks(x = x, min_gap = 1, threshold = -Inf,
                    min_mono_width = 4,windowsizes = c(1,3))
plot2(res, color = "extrm", legend = NULL)
# different mono left an right
res <- find_peaks(x = x, min_gap = 1, threshold = -Inf,
                    min_mono_width = c(4,1), windowsizes = c(1,3))
plot2(res, color = "extrm", legend = NULL)
# global only
res <- find_peaks(x = x, min_gap = 0, threshold = -Inf,
                    type2 = "global")
plot2(res, color = "extrm", legend = NULL)
# threshold only applies to local extrema
res <- find_peaks(x = x, min_gap = 0, threshold = 7,
                    type2 = "global")
plot2(res, color = "extrm", legend = NULL)
# NULL returned when nothing was found based on parameters
res <- find_peaks(x = x, min_gap = 0, threshold = 7,
                    type2 = "local")
plot2(res, color = "extrm", legend = NULL)
# minima
res <- find_peaks(x = x, type = "min", windowsizes = 4, min_gap = 0)
plot2(res, color = "extrm", legend = NULL)
# add more values
x2 <- interpolate_vec(x, len_out = 600)
res <- find_peaks(x = x2,
                    min_gap = 0,
                    threshold = -Inf,
                    min_mono_width = 1,
                    windowsizes = c(1))
plot2(res, color = "extrm", legend = NULL)
# artificial data with noise
x <- generate_synthetic_ts(length = 2000)
# use smoothing reduce the noise - otherwise there is no monotonic stretch
y <- find_peaks(x = x, smooth = TRUE)
plot2(y, color = "extrm", legend = FALSE)
# a quick and simple alternative; smoothing required!
brathering:::estimate_peak_position(stats::loess(
  x ~ index,
  data = data.frame(index = seq_along(x), x = x),
  span = 0.05
)$fitted, min_gap = 30)
}
